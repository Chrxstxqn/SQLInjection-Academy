# üîç Chapter 3: Vulnerability Identification

## Recognizing Vulnerable Code

Learn to identify SQL injection vulnerabilities in real code.

## Vulnerable Code Patterns

### ‚ùå Pattern 1: Direct String Concatenation

```php
// VULNERABLE!
$username = $_POST['username'];
$query = "SELECT * FROM users WHERE username='" . $username . "'";
$result = mysqli_query($conn, $query);
```

**Why it's vulnerable:** User input is directly inserted into the SQL query.

### ‚ùå Pattern 2: String Interpolation

```php
// VULNERABLE!
$username = $_GET['user'];
$query = "SELECT * FROM users WHERE username='$username'";
```

### ‚ùå Pattern 3: Format Strings

```python
# VULNERABLE!
username = request.form['username']
query = "SELECT * FROM users WHERE username='%s'" % username
cursor.execute(query)
```

### ‚ùå Pattern 4: F-Strings (Python 3.6+)

```python
# VULNERABLE!
username = request.form['username']
query = f"SELECT * FROM users WHERE username='{username}'"
cursor.execute(query)
```

## Testing for SQL Injection

### Method 1: Single Quote Test

Input a single quote: `'`

**Vulnerable response:**
```
You have an error in your SQL syntax near ''' at line 1
```

**Secure response:**
- No error, or generic "Invalid input" message

### Method 2: Boolean Logic Test

Test these inputs:
```
' OR '1'='1
' OR '1'='2
admin' --
admin' #
```

If behavior changes, the application is likely vulnerable.

### Method 3: Time Delay Test

```sql
-- MySQL
' OR SLEEP(5) --

-- SQL Server
' WAITFOR DELAY '00:00:05' --

-- PostgreSQL
' OR pg_sleep(5) --
```

If the response is delayed, SQL injection is present.

### Method 4: Error-Based Detection

Force an error:
```
'
admin''
admin' AND '1'='2
```

Look for:
- Database error messages
- Stack traces
- Different response behavior

## Vulnerable vs Secure Code

### Example 1: Login Authentication

#### ‚ùå VULNERABLE
```php
$username = $_POST['username'];
$password = $_POST['password'];

$query = "SELECT * FROM users WHERE username='$username' AND password='$password'";
$result = mysqli_query($conn, $query);

if (mysqli_num_rows($result) > 0) {
    echo "Login successful!";
}
```

#### ‚úÖ SECURE
```php
$username = $_POST['username'];
$password = $_POST['password'];

$stmt = $conn->prepare("SELECT * FROM users WHERE username = ?");
$stmt->bind_param("s", $username);
$stmt->execute();
$result = $stmt->get_result();

if ($result->num_rows > 0) {
    $user = $result->fetch_assoc();
    if (password_verify($password, $user['password'])) {
        echo "Login successful!";
    }
}
```

### Example 2: Search Function

#### ‚ùå VULNERABLE
```php
$search = $_GET['q'];
$query = "SELECT * FROM products WHERE name LIKE '%$search%'";
```

#### ‚úÖ SECURE
```php
$search = $_GET['q'];
$stmt = $conn->prepare("SELECT * FROM products WHERE name LIKE ?");
$searchTerm = "%" . $search . "%";
$stmt->bind_param("s", $searchTerm);
$stmt->execute();
```

### Example 3: User Profile

#### ‚ùå VULNERABLE
```php
$userId = $_GET['id'];
$query = "SELECT * FROM users WHERE id = $userId";
```

#### ‚úÖ SECURE
```php
$userId = $_GET['id'];
$stmt = $conn->prepare("SELECT * FROM users WHERE id = ?");
$stmt->bind_param("i", $userId);
$stmt->execute();
```

## Common Mistakes

### Mistake 1: Client-Side Validation Only

```javascript
// NOT ENOUGH!
function validateUsername(username) {
    if (username.includes("'")) {
        alert("Invalid character!");
        return false;
    }
    return true;
}
```

**Why:** Client-side validation can be bypassed easily.

### Mistake 2: Blacklist Filtering

```php
// WEAK PROTECTION!
$username = str_replace("'", "", $_POST['username']);
$username = str_replace('"', "", $username);
```

**Why:** Attackers can use encoding, double quotes, or other bypass techniques.

### Mistake 3: Escaping Alone

```php
// BETTER, BUT NOT PERFECT
$username = mysqli_real_escape_string($conn, $_POST['username']);
$query = "SELECT * FROM users WHERE username='$username'";
```

**Why:** Can still be bypassed in certain contexts. Prepared statements are better.

## Detection Checklist

### Code Review Checklist

- [ ] Check all database queries
- [ ] Look for string concatenation with user input
- [ ] Identify dynamic SQL construction
- [ ] Verify prepared statements are used
- [ ] Check input validation implementation
- [ ] Review error handling (don't expose DB errors)
- [ ] Test with malicious inputs

### Black-Box Testing Checklist

- [ ] Test all input fields
- [ ] Try single quotes in inputs
- [ ] Test with boolean logic
- [ ] Attempt time-based injection
- [ ] Check URL parameters
- [ ] Test POST data
- [ ] Examine cookies
- [ ] Test HTTP headers

## Lab Exercise 3.1: Code Review

Identify vulnerabilities in this code:

```php
<?php
$conn = new mysqli($host, $user, $pass, $db);

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $username = $_POST['username'];
    $password = md5($_POST['password']);
    
    $query = "SELECT * FROM users WHERE username='$username' AND password='$password'";
    $result = $conn->query($query);
    
    if ($result->num_rows > 0) {
        header('Location: dashboard.php');
    } else {
        echo "Invalid credentials!";
    }
}
?>
```

**Vulnerabilities Found:**
1. ‚ùå SQL Injection in username field
2. ‚ùå SQL Injection in password field
3. ‚ùå MD5 hashing (weak, not salted)
4. ‚ùå No prepared statements
5. ‚ùå No input validation

## Lab Exercise 3.2: Hands-On Testing

**Objective:** Test the vulnerable login page in this repository

1. Navigate to `/vulnerable/login.php`
2. Try these inputs:
   - Username: `'`
   - Username: `admin' --`
   - Username: `' OR '1'='1`
   - Username: `admin' OR '1'='1' --`

3. Document your findings:
   - Which inputs worked?
   - What was the SQL query generated?
   - How did you bypass authentication?

## Key Takeaways

- ‚úÖ String concatenation with user input = vulnerable
- ‚úÖ Single quote test is the quickest detection method
- ‚úÖ Prepared statements prevent SQL injection
- ‚úÖ Client-side validation is not security
- ‚úÖ Never trust user input

## Quiz: Chapter 3

### Question 1
Which input tests for SQL injection?
- A) test@email.com
- B) ' ‚úÖ
- C) password123
- D) admin

### Question 2
What is the best defense?
- A) Input filtering
- B) Blacklisting
- C) Prepared statements ‚úÖ
- D) Client validation

### Question 3
Why is client-side validation insufficient?
- A) It's slow
- B) Can be bypassed ‚úÖ
- C) Not user-friendly
- D) Requires JavaScript

---

**[‚Üê Previous: Chapter 2](02-sql-basics.md)** | **[Next: Chapter 4 ‚Üí](04-basic-techniques.md)**